---
title: "Project - Single covariate and mulit-covariate modelling"
author: "Amali Jayatileke"
date: "`r format(Sys.time(), '%d %B, %Y %H:%M:%OS')`"
output:
  html_document:
    toc: true
    theme: cerulean
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#load packages
library(sp)
library(sf)
library(spatstat)
library(rgbif)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(tidyverse)
library(raster)
library(mgcv)
```

### Load bears dataset

```{r}
# # get occurrences from GBIF
#bc_occ <- occ_search(
#   scientificName = "Ursus americanus",
#   country = "CA",
#   stateProvince = "British Columbia",
#   limit = 5000
# )
 
 # omit records with missing coordinates
#occ_data <- bc_occ$data[!is.na(bc_occ$data$decimalLongitude) & !is.na(bc_occ$data$decimalLatitude), ]
 
# save occurrences
#save(occ_data, file = "bc_bear_occurrences2.Rda")
```

```{r}
# load and view data
load("bc_bear_occurrences.Rda")
str(occ_data)
```

### Load covariates

```{r}
load("BC_Covariates.Rda")
summary(DATA)
```

### Visualize bear occurrences in BC

```{r}
# extract location columns
bears_loc <- occ_data[, c("decimalLongitude", "decimalLatitude", "month", "year")]
bears_loc_filtered <- subset(bears_loc, year %in% c(2020, 2021, 2022, 2023, 2024))
#bears_loc_filtered <- subset(bears_loc, year %in% c(2024))

# create sf object
bears_sf <- st_as_sf(
  bears_loc_filtered,
  coords = c("decimalLongitude", "decimalLatitude"),
  crs = 4326  # WGS84 (longitude/latitude)
)

# BC Albers projection
bears_sf_proj <- st_transform(bears_sf, crs = 3005)

# extract x, y coordinates
coords <- st_coordinates(bears_sf_proj)

# extract BC window
window_sf <- st_as_sf(DATA$Window) # convert SpatialPolygons to Simple Features (sf)
window_proj <- st_transform(window_sf, crs = 3005) # ensure same CRS
window <- as.owin(window_proj) # convert to owin using sf object
```

```{r}
# create ppp object
#bears_ppp <- ppp(
#   x = coords[,1],
#   y = coords[,2],
#  window = window
#)

#plot(bears_ppp, pch = 21, main = "Black bear occurrences in BC, 2020 - 2024")

```

```{r}
# To avoid plotting points outside window (illegal points)

# Intersect points with window
#bears_sf_proj_filtered <- bears_sf_proj[st_within(bears_sf_proj, window_proj, sparse = FALSE), ]
bears_sf_proj <- subset(bears_sf_proj, st_within(bears_sf_proj, window_proj, sparse = FALSE))

# Re-extract coordinates
coords_filtered <- st_coordinates(bears_sf_proj)

# Create new ppp object
bears_ppp <- ppp(
 x = coords_filtered[, 1],
 y = coords_filtered[, 2],
 window = window
)

plot(bears_ppp, pch = 21, main = "Black bear occurrences in BC, 2020 - 2024")

```

### Compare seasonal distributions

```{r}
# Define the seasons and corresponding colors
seasons <- list(
  winter = c(12, 1, 2),
  spring = c(3, 4, 5),
  summer = c(6, 7, 8),
  autumn = c(9, 10, 11)
)

# Create an empty list to store the ppp objects for each season
ppp_list <- list()

# Create an empty list to store the filtered data for each season
bears_sf_list <- list()

# Loop over seasons
for (i in 1:length(seasons)) {
  
  # Filter for each season
  season_name <- names(seasons)[i]
  season_months <- seasons[[i]]
  
  # Filter bears_loc_filtered by the season's months
  bears_loc_season <- bears_loc_filtered[bears_loc_filtered$month %in% season_months, ]
  
  # Print the number of observations for this season
  cat(season_name, ": ", nrow(bears_loc_season), " observations\n", sep="")
  
  # Create sf object for the filtered season
  bears_sf_season <- st_as_sf(
    bears_loc_season,
    coords = c("decimalLongitude", "decimalLatitude"),
    crs = 4326  # WGS84 (longitude/latitude)
  )
  
  # Transform to BC Albers projection
  bears_sf_season_proj <- st_transform(bears_sf_season, crs = 3005)
  
  # Store sf object in the list
  bears_sf_list[[season_name]] <- bears_sf_season_proj
  
  # Extract x, y coordinates
  coords <- st_coordinates(bears_sf_season_proj)
  
  # Create ppp object for each season
  suppressWarnings(
    bears_ppp_season <- ppp(
      x = coords[, 1],
      y = coords[, 2],
      window = window
    )
  )
  
  # Store ppp object in the list
  ppp_list[[season_name]] <- bears_ppp_season
}
```

```{r}
# Plot the four maps in a 2x2 grid
par(mfrow=c(2,2), mar=c(1,1,1,1))  # Set up a 2x2 plotting window

# Loop over ppp objects and plot them
for (i in 1:length(ppp_list)) {
  season_name <- names(ppp_list)[i]
  suppressWarnings(
    plot(ppp_list[[season_name]], main = paste(season_name, "(2020 - 2024)"), pch = 21)
  )
}
```

### Looking at covariates

```{r}
par(mfrow=c(2,2), mar=c(1,1,1,1))  # Set up a 2x2 plotting window
plot(DATA$Elevation,box = F, main = "Elevation")
plot(DATA$Forest,box = F, main = "Forest Cover")
plot(DATA$HFI,box = F, main = "HFI (Human Footprint Index)")
plot(DATA$Dist_Water, box = F, main = "Distance to Water")



```

### Assumptions

#### Quadrat test (5x5) conducted for each season to assess whether bear locations follow a random (CSR) distribution

```{r}
options(scipen = 0)

# Loop over ppp objects and conduct quadrat test of homogeneity
for (i in seq_along(ppp_list)) {
  season_name <- names(ppp_list)[i]
  
  # Perform quadrat test directly on ppp object
  qt_result <- quadrat.test(ppp_list[[i]], nx = 5, ny = 5)
  
  cat("\n--- Quadrat Test for", season_name, "---\n")
  print(qt_result)
}

```

### EDA

```{r}
elev <- na.omit(DATA$Elevation)
cover <- na.omit(DATA$Forest)
dist_water <- na.omit(DATA$Dist_Water)
hfi <- na.omit(DATA$HFI)

```

```{r}
is.im(dist_water)          # should return TRUE
is.ppp(bears_ppp)          # should return TRUE

```

#### rhohat plots

```{r, cache = TRUE}
# Overall
# intensity as a function of distance from water
rho <- rhohat(bears_ppp, dist_water) 
plot(rho, xlim=c(0, max(dist_water)), main = "Estimated rho vs Distance to Water", xlab = "Distance to water")

```

**Interpretation:**

-   Higher Intensity Close to Water

    -   At **short distances (0â€“2000 meters)**, the black line is **above** the red dashed line. This suggests that **bear occurrences are more likely near water** than average.

-   **Decreasing Intensity With Distance**

    -   As distance to water increases (beyond \~5000 meters), the relative intensity generally **declines**, often dipping below the mean (red dashed line). This means **bears are less likely to be found farther from water.**

-   **Multiple Peaks at Mid-Range Distances**

  -   There are small **bumps at \~3000, \~8000, and \~13000 meters**. These could indicate:
        
  -   Presence of **habitat patches** or **water-proximate features** that bears favor.

  -   **Random placement** of some bear points that just happen to cluster around a certain distance (e.g., \~10,000m from water) purely by chance.

  -   **Noise** or **measurement errors**

  -   Small sample size, bumps after 5000 m have larger confidence bands indicating high uncertainty due to smaller number of data point.

  -   Possibly transitional areas like wetlands or secondary water sources.

-   **Wide Confidence Band Beyond \~15000m**

    -   The grey band becomes **very wide** beyond 15,000 meters, and the estimate drops near zero.

    -   **Very few data points** (bear locations or quadrature points) are this far from water.

-   **Conclusion** Bear occurrences are strongly concentrated near water. There is a clear negative relationship between bear intensity and distance to water: the farther from water, the less likely a bear is to be found. This supports the ecological hypothesis that proximity to water is a key driver of black bear spatial distribution in BC.

```{r, cache = TRUE, fig.width = 10, fig.height = 8}
par(mfrow = c(2,2), mar = c(4, 4, 3, 2))
for (i in 1:length(ppp_list)) {
  season_name <- names(ppp_list)[i]
  rho <- rhohat(ppp_list[[season_name]], dist_water) 
  plot(rho, legend = FALSE, xlim = c(0, max(dist_water)), main = paste(season_name))
  legend("topright", legend = c(expression(hat(rho)(dist_water)), expression(bar(rho))), 
         col = c("black", "red"), lty = c(1, 2), bty = "n")
}

```

```{r, cache = TRUE}
# Seasonal 
# intensity as a function of distance from water
par(mfrow=c(2,2), mar=c(2,2,2,2))
for (i in 1:length(ppp_list)) {
  season_name <- names(ppp_list)[i]
  rho <- rhohat(ppp_list[[season_name]], dist_water) 
  plot(rho, xlim=c(0, max(dist_water)), main = paste(season_name))
}
```

```{r}
# Distance to water for bears locations

# im object to RasterLayer
im2raster <- function(im_obj) {
  # iamge to matrix
  m <- as.matrix(im_obj)
  # create raster object
  r <- raster(m)
  # range and extension
  ext <- c(im_obj$xrange[1] - im_obj$xstep/2,
           im_obj$xrange[2] + im_obj$xstep/2,
           im_obj$yrange[1] - im_obj$ystep/2,
           im_obj$yrange[2] + im_obj$ystep/2)
  extent(r) <- ext
  return(r)
}

# dist_water to RasterLayer
distw_raster <- im2raster(dist_water)

# dist_water in bear locations
bears_sf_proj$distw_value <- extract(distw_raster, bears_sf_proj) #For each bear point, extract the distance to water value from the raster.

summary(bears_sf_proj$distw_value)
```

**Interpretation:**

```{r}
hist(bears_sf_proj$distw_value, 
     main = "Distance to Water at bear locations", 
     xlab = "Distance to Water",
     col = "lightblue", border = "grey")

```

```{r}
distw_values <- getValues(distw_raster)

hist(distw_values, 
     main = "Global distribution of Distance to Water in BC", 
     xlab = "Distance to Water",
     col = "lightblue3", border = "grey")
```

### Distance to Water effects

```{r}

# Modelling without raster object
# model - Linear
mod_distw_clean <- ppm(bears_ppp, ~ dist_water, covariates = list(dist_water))
mod_distw_clean
```

```{r}

#Plot the model predictions
plot(mod_distw_clean,
     se = FALSE,
     superimpose = FALSE,
     box = F,
     main = "Model predictions - Linear effects")

#Overlay the park locations
plot(bears_ppp,
     pch = 16,
     cex = 0.7,
     cols = "white",
     add = TRUE)
plot(bears_ppp,
     pch = 16,
     cex = 0.5,
     cols = "black",
     add = TRUE)

```

```{r}

# Modelling without raster object
# model - Quadratic
mod_distw_clean_quad <- ppm(bears_ppp, ~ dist_water + I(dist_water^2), covariates = list(dist_water))
mod_distw_clean_quad
```

```{r}

#Plot the model predictions
plot(mod_distw_clean_quad,
     se = FALSE,
     superimpose = FALSE,
     box = F,
     main = "Model predictions - Quadratic effects")

#Overlay the park locations
plot(bears_ppp,
     pch = 16,
     cex = 0.7,
     cols = "white",
     add = TRUE)
plot(bears_ppp,
     pch = 16,
     cex = 0.5,
     cols = "black",
     add = TRUE)

```

```{r}
# model - Null
mod_distw_clean_null <- ppm(bears_ppp, ~ 1)
mod_distw_clean_null


```

#### Model evaluation

```{r}
# Compare models using AIC

# Null model
cat("AIC value for the null model:",AIC(mod_distw_clean_null))

# Linear model
cat("AIC value for the linear effects model:",AIC(mod_distw_clean))

# Quadratic model
cat("AIC value for the quadratic effects model:",AIC(mod_distw_clean_quad))

AIC(mod_distw_clean) - AIC(mod_distw_clean_quad)
```

**Interpretation**

-   Quadratic model has lowest AIC than null model. Therefore, fitted model with quadratic term of covariates (fit) is the better model

-   However note that the quadratic term was not significant.

```{r}
options(scipen = 0)

# Likelihood Ratio Test 

# Null model vs Linear effects
anova(mod_distw_clean_null, mod_distw_clean,  test = "LRT")

# Null model vs Quadratic effects
anova(mod_distw_clean_null, mod_distw_clean_quad,  test = "LRT")

# Likelihood Ratio Test 
anova(mod_distw_clean, mod_distw_clean_quad,  test = "LRT")
```

**Interpretation**

-   This performs a likelihood ratio test under the null hypothesis that the simpler model is sufficient.
-   The p-value (\< 2.2e-16) is very small (\< 0.05) when comparing the linear and quadratic effects with the null model. However the p-value is 0.4022 (\>0.05) when comparing the linear vs quadratic effects models, therefore, the **linear effects model is best fit**.

```{r}
# equation for the selected model
options(scipen = 999) # remove scientific notation
mod_distw_clean$coef

```

$$
\lambda_{bears}(u) = e^{-19.36334426884 -0.00005085943.distwater(u)}
$$

```{r}
# Test whether the observed data deviate significantly from the model predictions.
# Run the quadrat test
quadrat.test(mod_distw_clean, nx = 2, ny = 2)
```

**Interpretation** - The small p value( \< 2.2e-16) indicates that observed data deviate significantly from the model predictions.

```{r}
#Calculate the residuals
res <- residuals(mod_distw_clean)

#Visualise
plot(res,
     main = "Model residuals",
     cols = "transparent"
     )
```

```{r}
#Calculate the residuals
res <- residuals(mod_distw_clean)

#Visualise
plot(res,
     main = "Model residuals"
     )
```

```{r}
mod_res_clean <- residuals(mod_distw_clean, type = "pearson")

mod_res_clean$v[!is.finite(mod_res_clean$v)] <- NA

# Residuals
plot(mod_res_clean, main = "Model Residual Map (Pearson)", na.col = "transparent")
```

**Interpretation**

-   Since the residual plot shows no obvious patterns in the residuals, we can conclude the model is accurately capturing the trends in the dataset.

```{r}
#Calculate the partial residuals as a function of distance to water
par_res_distw <- parres(mod_distw_clean, "dist_water")

plot(par_res_distw,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for distance to water",
     xlab = "Distance to water (m)")
```

### Seasonal Distance to Water Effects

```{r}
options(scipen = 999) # remove scientific notation

# model for each season (individually)
models_seasonal <- list()

for (season in names(ppp_list)) {
  models_seasonal[[season]] <- ppm(ppp_list[[season]], ~ dist_water, covariates = list(dist_water))
  cat("Model for", season, ":\n")
  print(models_seasonal[[season]])
}
```

**Interpretation:**

1.  **Winter**

-   Intercept: significant

-   Slope (dist_water): (p \> 0.05) not significant

-   **Interpretation:**

    -   Bear occurrence does not significantly vary with distance to water. The flat slope suggests distance to water is not an important factor in winter â€” possibly because bears are less mobile due to hibernation.

2.  **Spring**

-   Intercept: significant

-   Slope (dist_water): -4.26e-05, p â‰ˆ 0.05 (\*)

-   **Interpretation:**

    -   There's weak evidence that bear occurrence decreases with increasing distance from water. Bears may start to rely on water sources as they emerge from hibernation and become active.

3.  **Summer**

-   Intercept: significant

-   Slope (dist_water): p \< 0.05 (\*)

-   **Interpretation:**

    -   Bear occurrence significantly decreases with distance from water.This is ecologically expected, as summer means more activity, foraging, and need for hydration.

4.  **Autumn**

-   Intercept: -20.72 (significant)

-   Slope (dist_water): -1.13e-04, p \< 0.001 (\*\*\*)

-   **Interpretation:**

    -   Bears are strongly associated with areas closer to water.This is the strongest seasonal effect â€” likely due to pre-hibernation foraging and increased movement and calorie intake near water sources.

#### Model Evaluation

```{r}
# Calculate partial residuals for each season's model
partial_residuals_seasonal <- list()

for (season in names(models_seasonal)) {
  partial_residuals_seasonal[[season]] <- parres(models_seasonal[[season]], covariate = "dist_water")
}

# Plot partial residuals in a 2x2 grid
par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))  # Larger margins for axes and labels

for (i in seq_along(partial_residuals_seasonal)) {
  season_name <- names(partial_residuals_seasonal)[i]
  plot(
    partial_residuals_seasonal[[i]],
    main = paste("Partial Residuals -", season_name),
    xlab = "Distance to Water",
    legend = F
  )
}
```

### Check Collinearity among covariates

```{r}
elev_raster <- im2raster(elev)
cover_raster <- im2raster(cover)
hfi_raster <- im2raster(hfi)

crs(elev_raster) <- CRS("+init=epsg:3005") 
crs(cover_raster) <- CRS("+init=epsg:3005") 
crs(hfi_raster) <- CRS("+init=epsg:3005") 

bears_sf_proj$elev_value <- extract(elev_raster, bears_sf_proj)
bears_sf_proj$cover_value <- extract(cover_raster, bears_sf_proj)
bears_sf_proj$hfi_value <- extract(hfi_raster, bears_sf_proj)


summary(bears_sf_proj$elev_value)
summary(bears_sf_proj$cover_value)
summary(bears_sf_proj$hfi_value)
```

```{r}
#Check for collinearity
cov_df <- data.frame(
  distw = bears_sf_proj$distw_value,
  elev = bears_sf_proj$elev_value,
  cover = bears_sf_proj$cover_value,
  hfi = bears_sf_proj$hfi_value
)
# Remove rows with NAs
cov_df_clean <- na.omit(cov_df)

# Check Correlation Matrix
cor_matrix <- cor(cov_df_clean)
print(round(cor_matrix, 2))

```

### Multi-covariate effects

```{r}
elev <- na.omit(DATA$Elevation)
cover <- na.omit(DATA$Forest)
dist_water <- na.omit(DATA$Dist_Water)
hfi <- na.omit(DATA$HFI)

# Problem:  Values of the covariate â€˜hfiâ€™ were NA or undefined at 0.32% (32 out of 9920) of the quadrature points 
#when fitting spatial point process models with ppm() in spatstat, missing covariate values at quadrature points will cause errors
 
model_all_linear <- ppm(bears_ppp, ~ elev + cover + dist_water + hfi, 
               covariates = list(elev = elev, cover = cover, hfi = hfi, dist_water = dist_water))

print(summary(model_all_linear))
```

```{r}
# im object to RasterLayer
im2raster <- function(im_obj) {
  # iamge to matrix
  m <- as.matrix(im_obj)
  # create raster object
  r <- raster(m)
  # range and extension
  ext <- c(im_obj$xrange[1] - im_obj$xstep/2,
           im_obj$xrange[2] + im_obj$xstep/2,
           im_obj$yrange[1] - im_obj$ystep/2,
           im_obj$yrange[2] + im_obj$ystep/2)
  extent(r) <- ext
  return(r)
}

# hfi to RasterLayer
hfi_raster <- im2raster(hfi)

hfi_matrix <- as.matrix(hfi)
media_hfi <- mean(as.vector(hfi_matrix), na.rm = TRUE)
cat("Mean HFI (without NA):", media_hfi, "\n")

# Impute NA values in HFI using the mean
hfi_clean <- eval.im( ifelse(is.na(hfi), media_hfi, hfi) )

summary(as.vector(as.matrix(hfi_clean)))

# elevation to RasterLayer
elev_raster <- im2raster(elev)

elev_matrix <- as.matrix(elev)
media_elev <- mean(as.vector(elev_matrix), na.rm = TRUE)
cat("Mean Elevation (without NA):", media_elev, "\n")

# Impute NA values in Elevation using the mean
elev_clean <- eval.im( ifelse(is.na(elev), media_elev, elev) )

summary(as.vector(as.matrix(elev_clean)))
```

```{r}
# Fit model using the image
model_all_linear <- ppm(bears_ppp, ~ elev + cover + dist_water + hfi,
                        covariates = list(elev = elev,
                                          cover = cover,
                                          dist_water = dist_water,
                                          hfi = hfi_clean))

print(summary(model_all_linear))
```

```{r}
model_all_quad <- ppm(bears_ppp, ~ elev + I(elev^2) + cover + I(cover^2)
                      + dist_water + I(dist_water^2) + hfi + I(hfi^2), 
                      covariates = list(elev = elev,
                                        cover = cover,
                                        dist_water = dist_water,
                                        hfi = hfi_clean))

summary(model_all_quad)
```

```{r}
# for forest cover the quadatric model was best
# quadratic for elevation
# dist_water - linear was best
# hfi - linear was best

model_all_agg <- ppm(bears_ppp, ~ elev + I(elev^2) + cover + I(cover^2)
                      + dist_water + hfi, 
                      covariates = list(elev = elev,
                                        cover = cover,
                                        dist_water = dist_water,
                                        hfi = hfi_clean))

summary(model_all_agg)
```

#### Model evaluation

```{r}
# Compare models using AIC

# Null model
AIC(mod_distw_clean_null)

# All 4 covariates Linear model
AIC(model_all_linear)

# All 4 covariates Quadratic model
AIC(model_all_quad)

# All 4 covariates Quadratic model
AIC(model_all_agg)

```

```{r}
options(scipen = 0)
# Likelihood Ratio Test 
anova(mod_distw_clean_null, model_all_linear,  test = "LRT")

# Likelihood Ratio Test 
anova(mod_distw_clean_null, model_all_quad,  test = "LRT")

# Likelihood Ratio Test 
anova(mod_distw_clean_null, model_all_agg,  test = "LRT")
```

```{r}
# Plot the log intensity using default plot method, by setting log = TRUE
plot(model_all_linear, se = FALSE, log = TRUE, n = 200,box = F, main = "Log-Intensity Prediction")

#Overlay the park locations
plot(bears_ppp,
     pch = 16,
     cex = 0.8,
     cols = "black",
     add = TRUE)
plot(bears_ppp,
     pch = 16,
     cex = 0.5,
     cols = "white",
     add = TRUE)

```

```{r}
#Run the quadrat test
quadrat.test(model_all_linear, nx = 4, ny = 2)

quadrat.test(model_all_quad, nx = 4, ny = 2)

quadrat.test(model_all_agg, nx = 4, ny = 2)
```

```{r}
#Calculate the partial residuals as a function of elevation
par_res_elev <- parres(model_all_linear, "elev")

#Calculate the relative intensity as a function of forest cover
par_res_forest <- parres(model_all_linear, "cover")

#Calculate the partial residuals as a function of elevation
par_res_distw <- parres(model_all_linear, "dist_water")

#Calculate the relative intensity as a function of forest cover
par_res_hfi <- parres(model_all_linear, "hfi")

#Side by side plotting
par(mfrow = c(2,2))
par(mar = c(4, 4, 2, 2))
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for elevation",
     xlab = "Elevation (m)")
plot(par_res_forest,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for forest cover",
     xlab = "Forest cover (%)")
plot(par_res_distw,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for distance to water",
     xlab = "Elevation (m)")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for HFI",
     xlab = "Forest cover (%)")
```

```{r}
#Calculate the partial residuals as a function of elevation
par_res_elev <- parres(model_all_agg, "elev")

#Calculate the relative intensity as a function of forest cover
par_res_forest <- parres(model_all_agg, "cover")

#Calculate the partial residuals as a function of elevation
par_res_distw <- parres(model_all_agg, "dist_water")

#Calculate the relative intensity as a function of forest cover
par_res_hfi <- parres(model_all_agg, "hfi")

#Side by side plotting
par(mfrow = c(2,2))
par(mar = c(4, 4, 2, 2))
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for elevation",
     xlab = "Elevation (m)")
plot(par_res_forest,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for forest cover",
     xlab = "Forest cover (%)")
plot(par_res_distw,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for distance to water",
     xlab = "Elevation (m)")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "Partial residual for HFI",
     xlab = "Forest cover (%)")
```

### Seasonal Multi-covariate effects ??

```{r}
options(scipen = 999) # remove scientific notation

# model for each season (individually)
models_seasonal_overall <- list()

for (season in names(ppp_list)) {
  models_seasonal_overall[[season]] <- ppm(ppp_list[[season]], ~ elev + I(elev^2) + 
                                             cover + I(cover^2) + 
                                             dist_water + hfi, 
                                        covariates = list(elev = elev_clean,
                                        cover = cover,
                                        dist_water = dist_water,
                                        hfi = hfi_clean))

  cat("Model for", season, ":\n")
  print(models_seasonal_overall[[season]])
}
```

**Interpretation**

-   Winter: Model did not converge, potentially due to collinearity or sparse points. Most variables significant, but I(cover\^2) and dist_water are not.

-   Spring/Summer/Autumn: Models converged well. All have a strong positive effect from hfi, and a curvilinear response to elevation and cover.

#### Model Evaluation
